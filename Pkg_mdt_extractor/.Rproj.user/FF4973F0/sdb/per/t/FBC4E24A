{
    "contents" : "srcexplore <- function(rpath,dpath,namespace)\n{\n#print(nmsimport(nmsres(namespace)))\n  #print(rpath)\n # print(dpath)\n  opkgpath<-readLines(\".//data//opkgpath.txt\")\n  opkgpath<-opkgpath[opkgpath!=\"\"]\n  temp<-list.files(rpath,pattern=\"\\\\.R|\\\\.S|\\\\.q|\\\\.r|\\\\.s\", full.names=T,include.dirs=T)\n  rfiles<-setdiff(temp,temp[grep(\"\\\\.rda|\\\\.in\",temp)])   #getting only r source files\n  \n  env<-attach(NULL, name = \"custom\")  #our main environment for function dependency analysis\n  if(length(rfiles)>=1)\n  {\n    for(i in 1:length(rfiles))\n    {\n      try(sys.source(rfiles[i], envir=env))\n      \n    }\n  }\n\n  originalfunlst<-NULL       #list of the original function present inside the package\n  originalfunlst<-as.vector(lsf.str(\"custom\"))\n  #print(try(rownames(foodweb(where=\"custom\")$funmat)))\n  \n  \n  \n  #temp<-(dependency(fvector))\n  #print(lsf.str())\n  #print(rpath)\n  \n  \n  \n  \n  \n  #dependency manipulation starts here\n  \n  dplst<-(deplist(dependency(finalvector(dpath))))\n  #print(dplst)\n  fdplst<-NULL # dependency list of the packages\n  #separating version from packages names\n   for(t in dplst)\n   {\n     fdplst<-c(fdplst,unlist(strsplit(t,\"\\\\(\"))[1])  # final dependency list by package names\n   }\ntx<-nmsimport(nmsres(namespace))\nfdplst<-c(tx,setdiff(fdplst,tx)) #as import field in namespace got more priority over depends in description file\n # print(fdplst)\n  pkgpath<-NULL\n  pkgname<-NULL\n  # getting file paths of the dependent packages\n  if(length(fdplst)>0)\n  {\n    timepass<-(readLines(file.path(getwd(),\"data/pkgpaths.txt\")))\n    dpnpaths<-file.path(readLines(file.path(getwd(),\"data/srcdir.txt\")),timepass)\n    dpnpaths<-dpnpaths[dpnpaths !=dpnpaths[grep(opkgpath,dpnpaths)]] # To package from identifying itself\n    for(t in fdplst)\n    {\n      temp<-paste(c(t,tolower(t)),collapse=\"|\")\n      temp2<-dpnpaths[grep(temp,dpnpaths)]\n     pkgpath<-c(pkgpath,temp2)   #path of the packages\n      if(length(temp2)>0)\n      {\n       pkgname[(length(pkgname)+1):(length(temp2)+length(pkgname))]<-t \n      }\n    }\n    \n  }\n  \n  funname<-NULL\n  finalfunlst<-NULL #final list of the functions with names of the vector representing the package in which it is found\n  funlst<-NULL #list of the function\n  names(pkgpath)<-pkgname                 #assigning names to the package paths that are found\n  \n  ext<-file.path(getwd(),'data/temp')\n  tmppkgpath<-NULL\n \n  if(length(pkgpath)>0)\n  {for(i in 1:length(pkgpath))  # loop in which everything is processed\n{path<-pkgpath[i]\n    names(path)<-pkgname[i]#assigning the names to the path as names are not passed with vector\n if(length(path)>0)\n  {if(grepl(\"tar|tgz\",path)==T)\n  {\n    tmp<-try(untar(path,exdir= ext,list=T)) # doesn't untar the files only list them\n    try(untar(path,exdir=ext))\n    tmpname<-pkgname[i]  # to get the name of the package we are processing\n    #print(tmpname)\n    #print(tmppkgpath)\n    #print(\"fuck u\")\n    fldpath1<-file.path(ext,dir(ext,recursive=F))     \n      temp<-fldpath1[grep(tmpname,fldpath1)]       # separating only the packages that we are currently processing.It doesn't seem working.\n      temp1<-readLines(\".//data//opkgtemppath.txt\")\n      temp1<-temp1[temp1!=\"\"]\n    fldpath1<-setdiff(fldpath1,temp1)   #separating the dependent packages and original packages\n    fldpath1<-setdiff(fldpath1,tmppkgpath) #separating the dependent packages from other dependent packages\n    #print(fldpath1)\n    fldpath<-dir(fldpath1,pattern=\"^R$\",recursive=F)\n    #print(fldpath)\n    tmppkgpath<-c(tmppkgpath,fldpath1)  #creating the list of dependent pacakges already processed\n    fldpath<-(file.path(fldpath1,(setdiff(fldpath,setdiff(fldpath,c('R'))))))\n    fldpath<-list.files(fldpath,pattern=\"\\\\.R|\\\\.S|\\\\.q|\\\\.r|\\\\.s\", full.names=T,include.dirs=T)\n    fldpath<-setdiff(fldpath,fldpath[grep(\"\\\\.rda|\\\\.in\",fldpath)])   #getting only r source files\n    if(length(grep(\"\\\\/R\\\\/\",tmp))>0)\n    {\n      #print(fldpath)\n      funextractlst<-funextract(fldpath)\n\n      funlst<-as.vector(funextractlst[[1]])   #getting list of functions present inside the dependent package\n      funlst<-c(pkgname[i],funlst)\n      rfpath<-funextractlst[[2]]    #path of the r source file in the dependent package\n      if(length(rfpath)>0)        #this code has literally raped my mind\n      {\n        for(i in 1:length(rfpath))\n        {  \n          try(sys.source(rfpath[i], envir =env))    #adding the package variables to main package environmennt\n        }\n      }\n      \n        }\n    unlink(fldpath1,recursive=T,force=T)  # for unlinking the folders\n  }\n \n  else if(grepl(\"zip\",path)==T)\n  {\n    tmp<-try(unzip(path,exdir= ext,list=T)) # doesn't untar the files only list them\n    try(unzip(path,exdir=ext))\n    tmpname<-pkgname[i]  # to get the name of the package we are processing\n    \n    #print(tmppkgpath)\n    #print(\"fuck u\")\n    fldpath1<-file.path(ext,dir(ext,recursive=F))     \n    temp<-fldpath1[grep(tmpname,fldpath1)]       # separating only the packages that we are currently processing.It doesn't seem working.\n    temp1<-readLines(\".//data//opkgtemppath.txt\")\n    temp1<-temp1[temp1!=\"\"]\n    fldpath1<-setdiff(fldpath1,temp1)   #separating the dependent packages and original packages\n    fldpath1<-setdiff(fldpath1,tmppkgpath) #separating the dependent packages from other dependent packages\n    #print(fldpath1)\n    fldpath<-dir(fldpath1,pattern=\"^R$\",recursive=F)\n    #print(fldpath)\n    tmppkgpath<-c(tmppkgpath,fldpath1)  #creating the list of dependent pacakges already processed\n    fldpath<-(file.path(fldpath1,(setdiff(fldpath,setdiff(fldpath,c('R'))))))\n    fldpath<-list.files(fldpath,pattern=\"\\\\.R|\\\\.S|\\\\.q|\\\\.r|\\\\.s\", full.names=T,include.dirs=T)\n    fldpath<-setdiff(fldpath,fldpath[grep(\"\\\\.rda|\\\\.in\",fldpath)])   #getting only r source files\n   # print(\"loop again\")\n    if(length(grep(\"\\\\/R\\\\/\",tmp))>0)\n    {\n      #print(fldpath)\n      funextractlst<-funextract(fldpath)\n     \n      funlst<-as.vector(funextractlst[[1]])   #getting list of functions present inside the dependent package\n      \n      rfpath<-funextractlst[[2]]   #path of the r source file in the dependent package\n      if(length(rfpath)>0)        #this code has literally raped my mind\n      {\n        for(i in 1:length(rfpath))\n        {  \n          try(sys.source(rfpath[i], envir =env))    #adding the package variables to main package environmennt\n        }\n      }\n      \n    }\n    unlink(fldpath1,recursive=T,force=T)  # for unlinking the folders\n      \n}\n }\n #print(as.vector(lsf.str(\"custom\")))\n# print(foodweb(where=\"custom\",plotting=F)$funmat)\n# print(funlst)\n  if(length(funlst)>0)\n  {\n      #funname[(length(funname)+1):(length(funname)+length(funlst))]<-names(path)\n    finalfunlst<-c(finalfunlst,list(funlst))  #creating final function list\n  }\n    }}\n  tp<-(nmsimpfrm(nmsres(namespace)))  #returns a list of function and its package name\n  tfun<-tp[[1]]\n  tname<-tp[[2]]\n  tlist<-c(list(tname),list(tfun))\n  ofuncallees<-NULL #list of calls to the original function in the same order as they are in vecctor.\n  if(length(tfun)!=0)\n {finalfunlst<-c(tlist,finalfunlst)}   #final function list\n  #print(\"here\")\n # print(\"fuck\")\n  fw<-NULL\n  try({fw<-foodweb(where=\"custom\",plotting=F)})\n # print(\"yaha\")\n  if(length(fw)>0)\n { for(fun in originalfunlst)\n  {\n    ofuncallees<-(c(ofuncallees,list(c(fun,callees.of(fun,fw)))))\n  }\n  #print(ofuncallees)\n  detach(custom) # it is detached before calling function because it changes base environment to this and then the actual i.e. my program can't find the functions of my program.\ndframefunction(originalfunlst,finalfunlst,ofuncallees)\n  #print(finalfunlst)\n # print(originalfunlst)\n #names(finalfunlst)<-funname  #final function list with names of vector element representing package in which a function belongs\n #print(finalfunlst) \n  #detach(custom)\n   #print(\"h\")\n  # end of dependency manipulation with list of the function of each dependent package in our hand\n}}\n\n\n\n\n#for extracting the names of the functions implemented inside the package\nfunextract<-function(path)\n{\n  #  print(path)\n\n  rpath<-path\n  rfiles<-NULL\n  if(length(rpath)>=1)\n  {  temp<-rpath[grep(\"\\\\.R|\\\\.S|\\\\.q|\\\\.r|\\\\.s\",rpath)]\n  rfiles<-setdiff(temp,temp[grep(\"\\\\.rda|\\\\.in\",temp)])\n  }\n  #print(rfiles)\n  environment<-attach(NULL, name = \"pkg\")\n  if(length(rfiles)>=1)\n  {\n    for(i in 1:length(rfiles))\n    {\n      try(sys.source(rfiles[i], envir =environment))\n    }\n  }\n  funclst<-as.vector(lsf.str(\"pkg\"))  \n  #print(funclst)\n  detach(pkg)\n  return(list(funclst,rfiles))\n}\n  ",
    "created" : 1371466312606.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "41|4|43|3|\n",
    "hash" : "1868802965",
    "id" : "FBC4E24A",
    "lastKnownWriteTime" : 1374656301,
    "path" : "E:/R/Pkg_mdt_extractor/R/SrcExploration.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : true,
    "type" : "r_source"
}