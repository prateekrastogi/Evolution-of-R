{
    "contents" : "start<-function()\n{\n  library(RODBC)\n  library(combinat)\n  library(RecordLinkage)\n  parsemtr()\n  parseauthor()\n}\nintdb<-function()\n{\n  channel<-odbcConnect('r',uid=\"root\",pwd=\"root\")\n  sqlQuery(channel,\"use finaldb;\")\n  return(channel)\n}\nclosedb<-function()\n{\n  odbcCloseAll()\n}\ndbwrite<-function(pkgid,name,email,role)\n{\n  if(length(pkgid)==1)\n  {\n    if(length(name)==0)\n  {\n    name<-c(\"NULL\")\n  }\n  if(length(email)==0)\n  {\n    email<-c(\"NULL\")\n  }\n  if(length(role)==0)\n  {\n    role<-c(\"Unknown\")\n  }\n    \n  channel<-intdb()\n  dbperson1<-sqlFetch(channel,'persons',rownames=F,colnames=F)[,1]\n    dbperson2<-sqlFetch(channel,'persons',rownames=F,colnames=F)[,2]\n    dbperson3<-sqlFetch(channel,'persons',rownames=F,colnames=F)[,3]\n    \n    authid<-c(1)\n    if(length(dbperson1)>0)\n    {\n      authid<-(max(dbperson1)+1)\n    }\n    data<-data.frame(authid,name,email,stringsAsFactors=F)\n    names(data)<-c(\"aid\",\"name\",\"email\")\n    data2<-data.frame(pkgid,authid,role,stringsAsFactors=F)\n    names(data2)<-c(\"pkgid\",\"personid\",\"rolecol\")\n    #print(data)\n    #print(data2)\n    if(email!=\"NULL\")\n    {\n      p<-match(email,dbperson3,nomatch=-1)\n      # if emailmatch\n      if(p!=-1)\n      {\n        if(name!=\"NULL\")\n        {tp<-match(name,dbperson2[p],nomatch=-1)\n         # if names match\n         if(tp!=-1)\n         {\n           timepass1<-sqlFetch(channel,'role',rownames=F,colnames=F)[,1]\n           timepass2<-sqlFetch(channel,'role',rownames=F,colnames=F)[,2]\n           taid<-dbperson1[p] #aid of the matched email and name id\n          temp<-match(taid,timepass2,nomatch=-1)\n           #check if they are same packages\n           if(temp!=-1)\n           {\n             pid<-timepass1[temp]\n             #if they are different packages then only add to role table\n             if(pid!=pkgid)\n             {\n               authid<-taid\n               data2<-data.frame(pid,authid,role)\n               names(data2)<-c(\"pkgid\",\"personid\",\"rolecol\")\n               try(sqlSave(channel,data2,tablename='role',append=T,rownames=F,colnames=F))\n             }\n           }\n         }\n         #if names don't match then add to persons and role table\n         else\n         {\n           try(sqlSave(channel,data,tablename='persons',append=T,rownames=F,colnames=F))\n           try(sqlSave(channel,data2,tablename='role',append=T,rownames=F,colnames=F))\n         }\n        }\n        # if name is NULL then add to person and role table\n        else\n        {\n          try(sqlSave(channel,data,tablename='persons',append=T,rownames=F,colnames=F))\n          try(sqlSave(channel,data2,tablename='role',append=T,rownames=F,colnames=F))\n        } \n        }\n      # if email don't match then add to persons and role table\n      else\n      {\n        try(sqlSave(channel,data,tablename='persons',append=T,rownames=F,colnames=F))\n        try(sqlSave(channel,data2,tablename='role',append=T,rownames=F,colnames=F))\n      } \n      \n      }\n    # if email is NULL then add to persons and role table\n    else\n    {\n      try(sqlSave(channel,data,tablename='persons',append=T,rownames=F,colnames=F))\n      try(sqlSave(channel,data2,tablename='role',append=T,rownames=F,colnames=F))\n    }\n    closedb()\n    }    \n}\nreadauthor<-function()\n{\n  channel<-intdb()\n  author<-sqlFetch(channel,'package',colnames=F,rownames=F)[,7]\n  pkgid<-sqlFetch(channel,'package',colnames=F,rownames=F)[,1]\n  closedb()\n  #print(pkgid)\n  return(list(author,pkgid))\n}\nreadmtr<-function()\n{\n  channel<-intdb()\n  author<-sqlFetch(channel,'package',colnames=F,rownames=F)[,8]\n  pkgid<-sqlFetch(channel,'package',colnames=F,rownames=F)[,1]\n  closedb()\n  return(list(author,pkgid))\n}\nparsemtr<-function()\n{\n  mtr<-readmtr()[[1]]\n  pkgid<-readmtr()[[2]]\n  if(length(mtr)>0)\n  {\n  for(i in 1:length(mtr))\n  {\n    if(length(mtr[i])>0)\n    {\n      temp<-unlist(strsplit(as.vector(mtr[i]),\"<\"))\n      if(length(temp)==2)  #according to the guidelines of r maintainer field\n      {\n        email<-NULL\n        name<-NULL\n        t<-(grep(\"@\",(gsub(\">\",\"\",temp))))\n        temp<-(gsub(\">\",\"\",temp))\n        if(length(t)<=1)\n        {\n          email<-temp[t]            #extracting email\n          name<-temp[temp!=email]   #extracting name\n          name<-sub(\" \",\"\",name)    #remove preponded and postponded spaces\n          revname<-paste(rev(unlist(strsplit(name,\"\"))),collapse=\"\")\n          revname<-sub(\" \",\"\",revname)\n          name<-paste(rev(unlist(strsplit(revname,\"\"))),collapse=\"\")\n          revemail<-paste(rev(unlist(strsplit(email,\"\"))),collapse=\"\")\n          revemail<-sub(\" \",\"\",revemail)\n          email<-paste(rev(unlist(strsplit(revemail,\"\"))),collapse=\"\")\n          pid<-pkgid[i]\n          role<-c(\"maintainer\")\n          dbwrite(pid,name,email,role)\n        }\n      }\n    }\n  }}\n}\nparseauthor<-function()\n{\n  author<-as.vector(readauthor()[[1]])\n  pkgid<-as.vector(readauthor()[[2]])\n if(length(author)>0)\n {\n   input<-NULL\n   lemail<-NULL\n   for(i in (1:length(author)))\n{\n     \n     auth<-author[i]\n     pid<-pkgid[i]\n    # print(pid)\n     tp<-paste(c(\"!\"),pid,collapse=NULL)\n     tp<-gsub(\"\\\\s\",\"\",tp)\n     #print(tp)\n     input<-c(input,tp,auth)  #for writing to the text file that has to be parsed by ner for name resolution\n     role<-c(\"author\")\n     temp<-unlist(strsplit(auth,\"<|>\")) #creating list of pkgid with corresponding emails of author field\n     t<-(temp[grep(\"@\",temp)])\n     if(length(t)>0)\n     {\n       lemail<-c(lemail,list(c(pid,t)))\n\n     }\n   }\n   # for executing ner we have to change environment to that directory.Computer specific thing.\n   setwd(\"C:\\\\ner\")\n   fileConn<-file(\".//input.txt\")\n   writeLines(input, fileConn)\n   close(fileConn)\n   ner(lemail)\n }\n}\nner<-function(lemail)\n{ \n  if(length(readLines(\"input.txt\")[readLines(\"input.txt\")!=\"\"])>0)\n  {\n  cmd<-c(\"ner input.txt\")\n  output<-system(cmd,intern=T,wait=T)\n  temp<-NULL\n  if(length(output)>9)\n  {\n    temp<-(output[9:(length(output)-1)]) # from analysing the output of ner only these\n  }\n  if(length(temp)>0)\n  {\n    for(n in temp)\n    {\n      timepass<-(unlist(strsplit(n,\"\\\\/O\")))\n      pid<-timepass[1]  # as pid is always the first element\n      auth<-timepass[grep(\"\\\\/PERSON\",timepass)]\n      auth<-gsub(\"\\\\/PERSON|<|!|>|[|]|$|%|&|(|\\\\^|\\\\+|\\\\-|)|,|\\\\.\",\"\",auth) # cleaning unncessary symbols\n      auth<-sub(\" \",\"\",auth)    #remove preponded and postponded spaces\n      author<-NULL\n      for(n in auth)\n      {revauthor<-paste(rev(unlist(strsplit(n,\"\"))),collapse=\"\")\n      revauthor<-sub(\" \",\"\",revauthor)\n      n<-paste(rev(unlist(strsplit(revauthor,\"\"))),collapse=\"\")\n      author<-c(author,n)   # final author names of the particular package\n    }\n     # print(pid)\n     # print(author)\n     #print(lemail)\n      merge(pid,author,lemail)\n    # start from here\n    }\n  }\n}}\n",
    "created" : 1372849605774.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "9|1|13|0|\n15|1|17|0|\n19|1|110|0|\n100|5|103|4|\n100|5|103|4|\n121|1|127|0|\n129|1|163|0|\n",
    "hash" : "3499615170",
    "id" : "6D09118",
    "lastKnownWriteTime" : 1376623525,
    "path" : "E:/R/Author Merging/R/Author Merging.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}